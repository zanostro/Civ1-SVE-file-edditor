//------------------------------------------------
//--- 010 Editor v11.0.1 Script File
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
//   History: 
//------------------------------------------------

#define CIVS_COUNT 8
#define LEADER_COUNT 14

#define GOLD_MAX 30000
#define MAX_PLAYER_NAME_LENGTH 13

#define MAX_STRING_LEN 10000
#define TECH_COUNT 73




void SetPlayerGold(short leader_id, short amount){
    if(amount > 30000) amount = GOLD_MAX;
    if(amount < 0) amount = 0;

    Gold[leader_id] = amount;
}

void SetLeaderName(short leader_id, string name){
    int len = Min(MAX_PLAYER_NAME_LENGTH, Strlen(name));
    Memcpy(LeaderNames[leader_id].Name, name, len, 0, 0);
}


short GetHumanPlayerId(){
    return HumanPlayerCiv;
}


string GetLeaderName(short leader_id){
    return LeaderNames[leader_id].Name;
}


// Get pointer to the correct 16-bit flag inside the struct
short GetTechRegister(int tech_id)
{
    int index = tech_id / 16;
    return Min(index, 4);
}

short GetTechRegOffset(int tech_id){
    int index = tech_id % 16;
    return Max(0, Min(15, index));
}


int CountBits(unsigned short value) {
    int count = 0;
    while (value) {
        count += value & 1;
        value >>= 1;
    }
    return count;
}



void UpdateTechMaskSet(short leader_id, int block, unsigned short mask) {
    unsigned short before = 0;
    unsigned short after = 0;

    switch (block) {
        case 0: before = DiscoveredCivAdvances[leader_id].flag_tech0; after = (unsigned short)(before | mask); DiscoveredCivAdvances[leader_id].flag_tech0 = after; break;
        case 1: before = DiscoveredCivAdvances[leader_id].flag_tech1; after = (unsigned short)(before | mask); DiscoveredCivAdvances[leader_id].flag_tech1 = after; break;
        case 2: before = DiscoveredCivAdvances[leader_id].flag_tech2; after = (unsigned short)(before | mask); DiscoveredCivAdvances[leader_id].flag_tech2 = after; break;
        case 3: before = DiscoveredCivAdvances[leader_id].flag_tech3; after = (unsigned short)(before | mask); DiscoveredCivAdvances[leader_id].flag_tech3 = after; break;
        case 4: before = DiscoveredCivAdvances[leader_id].flag_tech4; after = (unsigned short)(before | mask); DiscoveredCivAdvances[leader_id].flag_tech4 = after; break;
        default: return;
    }
    if (after != before)
        DiscoveredAdvancesCount[leader_id] += CountBits(after) - CountBits(before);
}

void UpdateTechMaskClear(short leader_id, int block, unsigned short mask) {
    unsigned short before = 0;
    unsigned short after = 0;

    switch (block) {
        case 0: before = DiscoveredCivAdvances[leader_id].flag_tech0; after = (unsigned short)(before & (unsigned short)~mask); DiscoveredCivAdvances[leader_id].flag_tech0 = after; break;
        case 1: before = DiscoveredCivAdvances[leader_id].flag_tech1; after = (unsigned short)(before & (unsigned short)~mask); DiscoveredCivAdvances[leader_id].flag_tech1 = after; break;
        case 2: before = DiscoveredCivAdvances[leader_id].flag_tech2; after = (unsigned short)(before & (unsigned short)~mask); DiscoveredCivAdvances[leader_id].flag_tech2 = after; break;
        case 3: before = DiscoveredCivAdvances[leader_id].flag_tech3; after = (unsigned short)(before & (unsigned short)~mask); DiscoveredCivAdvances[leader_id].flag_tech3 = after; break;
        case 4: before = DiscoveredCivAdvances[leader_id].flag_tech4; after = (unsigned short)(before & (unsigned short)~mask); DiscoveredCivAdvances[leader_id].flag_tech4 = after; break;
        default: return;
    }
    if (after != before)
        DiscoveredAdvancesCount[leader_id] += CountBits(after) - CountBits(before); // may be negative
}


// Updates tracking statistics
void Update_tech_stats(){
    short max = 0;
    int i = 0;
    for(i = 0; i < CIVS_COUNT; i++) if(DiscoveredAdvancesCount[i] > max) max = DiscoveredAdvancesCount[i];
    MaxTechCount = max;
}

enum <short> TECH_MODE{
    TECH_MODE_DISCOVER = 1,
    TECH_MODE_UNDISCOVER = 0
};


// Tracks which civs first discover said tech
void UpdateTechFistDiscovered(short leader_id, int tech_id, enum TECH_MODE mode){
    short id = TechFirstInventors[tech_id];
    if(mode == TECH_MODE_DISCOVER && id == CIV_NONE) TechFirstInventors[tech_id] = leader_id;
    else if(mode == TECH_MODE_UNDISCOVER && id == leader_id) TechFirstInventors[tech_id] = CIV_NONE;
}


// Updates a table of tech sources
void UpdateTechSource(short leader_id, int tech_id, enum TECH_MODE mode){
    short mask = 0;
    if(mode == TECH_MODE_UNDISCOVER) mask = -1;
    else if(leader_id != HumanPlayerCiv) mask = leader_id;
    SourceCivsForTechnologies[leader_id].techs[tech_id] = mask;
}


// Usage: LeaderUpdateTech(0, TECH_ALPHABET, TECH_MODE_DISCOVER);
void LeaderUpdateTech(short leader_id, enum TechID tech_id, enum TECH_MODE mode){
    if(tech_id >= TECH_COUNT || tech_id < 0 || leader_id < 0 || leader_id >= LEADER_COUNT) return; // failsafe

    int block  = GetTechRegister(tech_id);    // 0..4
    int offset = GetTechRegOffset(tech_id);   // 0..15
    unsigned short mask = (unsigned short)(1u << offset);

    //SourceCivsForTechnologies[8];

    if(mode == TECH_MODE_DISCOVER) UpdateTechMaskSet(leader_id, block, mask);
    else UpdateTechMaskClear(leader_id, block, mask);

    // Update tracking
    Update_tech_stats();
    UpdateTechSource(leader_id, tech_id, mode);
    UpdateTechFistDiscovered(leader_id, tech_id, mode);
}



void LeaderDiscoverAll(short leader_id){
    int i = 0;
    for(i = 0; i < TECH_DUMMY1; i++) {
        LeaderUpdateTech(leader_id, i, TECH_MODE_DISCOVER);
    }
}


void LeaderUnDiscoverAll(short leader_id){
    int i = 0;
    for(i = 0; i < TECH_DUMMY1; i++) {
        LeaderUpdateTech(leader_id, i, TECH_MODE_UNDISCOVER);
    }
}


void LeaderDiscoverTechFromList(short leader_id, short tech_ids[], int count) {
    int i = 0;
    for (i = 0; i < count; i++) {
        LeaderUpdateTech(leader_id, i, TECH_MODE_DISCOVER);
    }
}

void LeaderRemoveTechFromList(short leader_id, short tech_ids[], int count) {
    int i = 0;
    for (i = 0; i < count; i++) {
        LeaderUpdateTech(leader_id, i, TECH_MODE_UNDISCOVER);
    }
}



LeaderUpdateTech(3, TECH_UNIVERSITY, TECH_MODE_DISCOVER);